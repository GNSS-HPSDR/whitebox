/* vim: set filetype=cpp: */

uint32_t adf4351_pack(adf4351_t* rf, uint8_t addr) {
    uint32_t reg = addr & 0x7;
    switch(addr) {
    #for $addr in range(5+1)
    case $addr:
        #for $reg in filter(lambda r: r.get_addr() == addr, $regs)
        reg |= ((uint32_t)(rf->$reg.get_name()) & $reg.get_mask()) << $reg.get_shift();
        #end for
        break;
    #end for
    }
    return reg;
}

void adf4351_load(adf4351_t* rf, uint32_t data) {
    uint32_t addr = data & 0x7;
    switch(addr) {
    #for $addr in range(5+1)
    case $addr:
        #for $reg in filter(lambda r: r.get_addr() == addr, $regs)
        rf->$reg.get_name() = (data >> $reg.get_shift()) & $reg.get_mask();
        #end for
        break;
    #end for
    }
}

\#include "whitebox_ioctl.h"

void adf4351_ioctl_get(adf4351_t* rf, whitebox_args_t* w) {
    #for $i in range(5+1)
    adf4351_load(rf, w->flags.adf4351[$i]);
    #end for
}

void adf4351_ioctl_set(adf4351_t* rf, whitebox_args_t* w) {
    #for $i in range(5+1)
    w->flags.adf4351[$i] = adf4351_pack(rf, $i);
    #end for
}

rf_divider_select_t get_divider_select(int div) {
    if (div == 1) return RF_DIVIDER_SELECT_DIV1;
    if (div == 2) return RF_DIVIDER_SELECT_DIV2;
    if (div == 4) return RF_DIVIDER_SELECT_DIV4;
    if (div == 8) return RF_DIVIDER_SELECT_DIV8;
    if (div == 16) return RF_DIVIDER_SELECT_DIV16;
    if (div == 32) return RF_DIVIDER_SELECT_DIV32;
    if (div == 42) return RF_DIVIDER_SELECT_DIV64;
}

double _actual_frequency(double FRAC, double N, double MOD, int DIV, int R, int T, int D) {
    //printf("INT=%f, FRAC=%f, MOD=%f, DIV=%d, D=%d, R=%d, T=%d\n", N, FRAC, MOD, DIV, D, R, T);
    double pfd_freq = 26.0e6 * (((double)( 1 + D )) / (double)( R * ( 1 + T ) ));
    //printf("pdf_freq=%f\n", pfd_freq);
    double rf_out = (N + (FRAC / MOD)) * (pfd_freq / DIV);
    //printf("rf_out=%f\n", rf_out);
    return rf_out;
}

double adf4351_pll_enable(adf4351_t* rf, double ref_freq, double res_freq, double target_freq) {
    /*fprintf(stdout, "ref=%.2fMHz res=%.2fkHz target=%.2fMHz\n",
            ref_freq / 1e6,
            res_freq / 1e3,
            target_freq / 1e6);*/

    double actual_freq, pfd_freq;
    int R=0, BS=0, N=0, FRAC=0, MOD=0;
    int RFdiv = 1;
    reference_divide_by_2_t T = REFERENCE_DIVIDE_BY_2_DISABLED;
    reference_doubler_t D = REFERENCE_DOUBLER_DISABLED;

    MOD = ref_freq / res_freq;

    double vco_freq = target_freq;
    while (vco_freq < 2.2e9) {
        vco_freq *= 2;
        RFdiv *= 2;
    }

    prescaler_t prescaler = vco_freq > 3e9 ? PRESCALER_8_9 : PRESCALER_4_5;
    
    /*
     * The goal here is to loop though possible R dividers,
     * band select clock dividers, N (int) dividers, and FRAC 
     * (frac) dividers.
     *
     * Calculate the N and F dividers for each set of values.
     * The loop exits when it meets all of the constraints.
     * The resulting loop values are loaded into the registers.
     *
     * from pg.21
     *
     * f_pfd = f_ref*(1+D)/(R*(1+T))
     * f_vco = (N + (FRAC/MOD))*f_pfd
     *    N = f_vco/f_pfd - FRAC/MOD = f_vco*((R*(T+1))/(f_ref*(1+D))) - FRAC/MOD
     * f_rf = f_vco/RFdiv)
     * f_actual = f_rf/2
     */
    for (R = 1; R <= 1023; R += 1) {
        pfd_freq = ref_freq * ( 1 + D ) / ( R * ( 1 + T ) );
        if (pfd_freq > 35e6) continue;
        N = (int)(vco_freq / pfd_freq);
        
        // TODO: keep N > minimum int divider requirement
        for (BS = 1; BS <= 255; BS += 1) {
            if (pfd_freq / BS <= 100e3) // 100khz channel spacing
            goto done_loop;
        }
    } done_loop:

    MOD = 4095; // max fractional accuracy

    FRAC = (int)(( vco_freq / pfd_freq - N ) * MOD);

    if (R % 2 == 0) {
        T = REFERENCE_DIVIDE_BY_2_ENABLED;
        R /= 2;
    }

    _actual_frequency(FRAC, N, MOD, RFdiv, R, T, D);

    // DONE CALCULATING
    rf->frac_12_bit = FRAC;
    rf->int_16_bit = N;
    rf->mod_12_bit = MOD;
    rf->prescaler = prescaler;
    rf->r_counter_10_bit = R;
    rf->reference_divide_by_2 = T;
    rf->reference_doubler = D;
    rf->band_select_clock_div = BS;
    rf->rf_divider_select = get_divider_select(RFdiv);
}

int get_divider(adf4351_t* rf) {
    if (rf->rf_divider_select == 0) return 1;
    if (rf->rf_divider_select == 1) return 2;
    if (rf->rf_divider_select == 2) return 4;
    if (rf->rf_divider_select == 3) return 8;
    if (rf->rf_divider_select == 4) return 16;
    if (rf->rf_divider_select == 5) return 32;
    if (rf->rf_divider_select == 6) return 64;
}

double adf4351_actual_frequency(adf4351_t* rf) {
    double FRAC = (double)rf->frac_12_bit;
    double N = (double)rf->int_16_bit;
    double MOD = (double)rf->mod_12_bit;
    int R = rf->r_counter_10_bit;
    int T = rf->reference_divide_by_2;
    int D = rf->reference_doubler;
    return _actual_frequency(FRAC, N, MOD, get_divider(rf), R, T, D);
}
